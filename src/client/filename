import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const canvas = document.getElementById('scene');
const startButton = document.getElementById('start-session');
const joinButton = document.getElementById('join-session');
const joinInput = document.getElementById('join-code');
const hudPanel = document.getElementById('hud-panel');
const sessionPanel = document.getElementById('session-panel');
const sessionCodeLabel = document.getElementById('session-code');
const outfitColorInput = document.getElementById('outfit-color');
const accentColorInput = document.getElementById('accent-color');
const outfitSelect = document.getElementById('outfit-select');
const hairSelect = document.getElementById('hair-select');
const decorColorInput = document.getElementById('decor-color');
const decorSelect = document.getElementById('decor-select');
const snowToggle = document.getElementById('snow-toggle');
const photoModeBtn = document.getElementById('photo-mode');
const toastEl = document.getElementById('toast');

const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
  alpha: true,
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050b17);
scene.fog = new THREE.FogExp2(0x040915, 0.02);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 6, 14);

const cameraTarget = new THREE.Vector3(0, 1, 0);
const cameraOrbit = {
  yaw: 0,
  pitch: 0.4,
  distance: 13,
};
const pointerState = { x: 0.5, y: 0.5 };
const cameraBase = { yaw: cameraOrbit.yaw, pitch: cameraOrbit.pitch };
const dragState = {
  active: false,
  moved: false,
  lastX: 0,
  lastY: 0,
  pointerId: null,
};
let autoFollowPaused = false;
const AUTO_RESUME_DELAY_MS = 1000;
let autoResumeTimeout = null;
const EDGE_THRESHOLD = 0.08;
const EDGE_PAN_SPEED = 0.6;
const EDGE_TILT_SPEED = 0.4;

const clock = new THREE.Clock();
const placementSurfaces = [];
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

const localState = {
  playerId: null,
  sessionCode: null,
  avatarColors: {
    outfit: outfitColorInput.value,
    accent: accentColorInput.value,
  },
  decorType: decorSelect.value,
  decorColor: decorColorInput.value,
  snowMultiplier: 1,
  partnerPresent: false,
  outfit: outfitSelect.value,
  hair: hairSelect.value,
};

const inputState = {
  forward: false,
  backward: false,
  left: false,
  right: false,
};

const remotePlayers = new Map();
const decorationMeshes = new Map();

const village = buildVillage();
placementSurfaces.push(village.ground, ...village.cabins);

const localPlayer = createAvatar({
  colors: localState.avatarColors,
  outfit: localState.outfit,
  hair: localState.hair,
});
localPlayer.group.position.set(0, 1, 0);
scene.add(localPlayer.group);

const snowSystem = createSnowSystem(600);
scene.add(snowSystem.points);

setupUI();
setupInput();
setInterval(() => {
  if (localState.sessionCode) {
    sendAvatarUpdate();
  }
}, 2500);
animate();

const network = createNetwork();

function normalizeAvatarAppearance(avatar = {}) {
  return {
    colors: {
      outfit: avatar.colors?.outfit || '#ffb7c5',
      accent: avatar.colors?.accent || '#ffd966',
    },
    outfit: avatar.outfit || 'parka',
    hair: avatar.hair || 'soft-wave',
  };
}

function createNetwork() {
  let ws;
  const queue = [];

  function ensureConnection() {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
      return;
    }

    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    ws = new WebSocket(`${protocol}://${window.location.host}`);

    ws.addEventListener('open', () => {
      queue.splice(0, queue.length).forEach((msg) => ws.send(msg));
    });

    ws.addEventListener('message', (event) => {
      const payload = JSON.parse(event.data);
      switch (payload.type) {
        case 'session_created':
        case 'session_joined':
          handleSessionJoined(payload.data);
          break;
        case 'session_state':
          hydrateWorld(payload.data);
          break;
        case 'error':
          showToast(payload.message || 'Server error.');
          break;
        default:
          break;
      }
    });

    ws.addEventListener('close', () => {
      showToast('Connection lost. Attempting to reconnect…');
      setTimeout(ensureConnection, 1000);
    });
  }

  function send(type, data = {}) {
    const stringified = JSON.stringify({ type, data });
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      queue.push(stringified);
      ensureConnection();
      return;
    }
    ws.send(stringified);
  }

  return { send, ensureConnection, get socket() { return ws; } };
}

function buildVillage() {
  const groundGeo = new THREE.PlaneGeometry(160, 160, 120, 120);
  const pos = groundGeo.attributes.position;
  for (let i = 0; i < pos.count; i += 1) {
    const x = pos.getX(i);
    const z = pos.getZ(i);
    const noise = (Math.sin(x * 0.08) + Math.cos(z * 0.08)) * 0.2;
    pos.setY(i, noise * 0.2);
  }
  pos.needsUpdate = true;

  const groundMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    roughness: 0.95,
    metalness: 0,
    clearcoat: 0.2,
    clearcoatRoughness: 0.15,
    side: THREE.DoubleSide,
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.receiveShadow = true;
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);
  const groundBase = new THREE.Mesh(
    new THREE.PlaneGeometry(320, 320),
    new THREE.MeshBasicMaterial({ color: 0xffffff }),
  );
  groundBase.position.y = -0.05;
  groundBase.rotation.x = -Math.PI / 2;
  groundBase.renderOrder = -1;
  scene.add(groundBase);

  const sparkleGeometry = new THREE.BufferGeometry();
  const sparklePositions = new Float32Array(600 * 3);
  for (let i = 0; i < 600; i += 1) {
    sparklePositions[i * 3] = (Math.random() - 0.5) * 140;
    sparklePositions[i * 3 + 1] = Math.random() * 0.3 + 0.1;
    sparklePositions[i * 3 + 2] = (Math.random() - 0.5) * 140;
  }
  sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
  const snowSparkle = new THREE.Points(
    sparkleGeometry,
    new THREE.PointsMaterial({ color: 0xffffff, size: 0.45, transparent: true, opacity: 0.35 }),
  );
  snowSparkle.position.y = 0.05;
  scene.add(snowSparkle);

  const ambient = new THREE.HemisphereLight(0xfff9e8, 0x0a1824, 0.9);
  scene.add(ambient);

  const moon = new THREE.DirectionalLight(0xc7d5ff, 0.65);
  moon.position.set(-10, 20, 10);
  moon.castShadow = true;
  moon.shadow.mapSize.set(2048, 2048);
  scene.add(moon);

  const hearth = new THREE.PointLight(0xffb7c5, 1.4, 45);
  hearth.position.set(0, 6, 0);
  scene.add(hearth);

  const cabinSurfaces = [];
  const cabinConfigs = [
    {
      id: 'gingerbread-haven',
      position: { x: -34, z: -26 },
      style: {
        facing: 0,
        body: { width: 18, height: 6.2, depth: 11, color: 0xd9ab78 },
        upperBody: { width: 16, height: 3.6, depth: 9.5, offsetY: 0.5, color: 0xe3c09a },
        modules: [
          { width: 8, height: 4.2, depth: 5.5, offsetX: -12, offsetZ: 3, color: 0xf2cfaa },
          { width: 6, height: 5, depth: 4.8, offsetX: 11, offsetZ: -3, color: 0xd9ab78 },
        ],
        roof: { color: 0x8d2f18, height: 2.6, type: 'gable' },
        trimColor: 0xfff4da,
        doorColor: 0x4a2415,
        porch: { depth: 3.4, widthFactor: 1.3, steps: true, rails: true },
        balcony: { width: 7, depth: 2.4, height: 5.6 },
        dormers: [
          { width: 3, height: 2.2, depth: 3, offsetX: -2.5, offsetZ: -0.5 },
          { width: 3, height: 2.2, depth: 3, offsetX: 2.5, offsetZ: 0.5 },
        ],
        chimney: true,
        wreathColor: 0x1c8c53,
        stringLightsColor: 0xfff6c8,
      },
    },
    {
      id: 'pine-grove',
      position: { x: 34, z: -28 },
      style: {
        facing: 0,
        body: { width: 20, height: 6.4, depth: 12, color: 0xdab082 },
        upperBody: { width: 18, height: 3.6, depth: 10, offsetY: 0.3, color: 0xdab082 },
        modules: [
          { width: 10, height: 4.4, depth: 8, offsetX: 12, offsetZ: 4, color: 0xe1b88b },
          { width: 8, height: 3.8, depth: 5.5, offsetX: -14, offsetZ: 6, color: 0xd3a579 },
        ],
        roof: { color: 0x1b5a48, height: 2.2, type: 'gable', tilt: Math.PI / 3.8 },
        trimColor: 0xe4f0d8,
        doorColor: 0x8f2b2b,
        porch: { depth: 3.4, widthFactor: 1.4, steps: true, wrap: true },
        chimney: true,
        wreathColor: 0xe74c3c,
        stringLightsColor: 0xa3ffd4,
        shuttersColor: 0xa5c99b,
        dormers: [{ width: 3, height: 2.2, depth: 2.5, offsetX: 0, offsetZ: 0 }],
      },
    },
    {
      id: 'aurora-chalet',
      position: { x: -34, z: 26 },
      style: {
        facing: Math.PI,
        body: { width: 13, height: 5, depth: 9.5, color: 0xdcb388 },
        upperBody: {
          width: 12,
          height: 3.2,
          depth: 8,
          offsetY: 0.4,
          color: 0xdcb388,
        },
        modules: [
          { width: 7.5, height: 3.5, depth: 6.5, offsetZ: -6.5, color: 0xeacaa3 },
        ],
        roof: { color: 0x284c73, height: 2.7, type: 'a_frame' },
        trimColor: 0xd3f0ff,
        doorColor: 0xfff0c1,
        wreathColor: 0x51a3a3,
        stringLightsColor: 0x9de1ff,
        porch: { depth: 2.2, widthFactor: 0.9, steps: true },
        chimney: false,
        balcony: { width: 5, depth: 2.5, height: 4.6, railingColor: 0x9de1ff },
        dormers: [
          { width: 2.4, height: 2, depth: 2, offsetX: -2, offsetZ: 0.3 },
        ],
      },
    },
    {
      id: 'starlit-lodge',
      position: { x: 34, z: 30 },
      style: {
        facing: Math.PI,
        body: { width: 22, height: 6.6, depth: 12, color: 0xdcb98f },
        upperBody: {
          width: 18,
          height: 4,
          depth: 10.5,
          offsetY: 0.6,
          color: 0xdcb98f,
        },
        modules: [
          { width: 10, height: 4.6, depth: 6.5, offsetX: 14, color: 0xe8c6a2 },
          { width: 9, height: 4, depth: 5.5, offsetX: -15, offsetZ: -4.5, color: 0xdcb98f },
        ],
        roof: { color: 0x55321f, height: 2.8, type: 'gable', tilt: Math.PI / 4.2 },
        trimColor: 0xffd78a,
        doorColor: 0x3e1a0d,
        porch: { depth: 3.8, widthFactor: 1.35, steps: true, rails: true, columns: 4 },
        balcony: { width: 8, depth: 3.5, height: 6.2, railingColor: 0xffd78a },
        chimney: true,
        wreathColor: 0xfde68a,
        stringLightsColor: 0xff9aa2,
        dormers: [
          { width: 3.2, height: 2.2, depth: 2.8, offsetX: -4.5, offsetZ: -0.4 },
          { width: 3.2, height: 2.2, depth: 2.8, offsetX: 4.5, offsetZ: 0.4 },
        ],
      },
    },
  ];

  const walkwayAnchors = [];

  cabinConfigs.forEach((config) => {
    const cabin = createCabin(config);
    cabinSurfaces.push(...cabin.surfaces);
    scene.add(cabin.group);
    placementSurfaces.push(...cabin.surfaces);
    walkwayAnchors.push({
      position: config.position,
      front: computeFrontAnchor(config),
    });
  });

  const pathSegments = createCurvedVillagePaths(walkwayAnchors);

  const pathAreas = computePathBounds(pathSegments);
  const snowMounds = new THREE.Group();
  for (let i = 0; i < 40; i += 1) {
    const radius = Math.random() * 2.2 + 1.6;
    const height = radius * (0.5 + Math.random() * 0.3);
    const mound = createSnowMound(radius, height, 0xffffff);
    let attempts = 0;
    do {
      mound.position.set((Math.random() - 0.5) * 120, 0.02, (Math.random() - 0.5) * 120);
      attempts += 1;
    } while (isOnPath(mound.position, pathAreas) && attempts < 10);
    snowMounds.add(mound);
  }
  scene.add(snowMounds);

  const cabinPiles = new THREE.Group();
  cabinConfigs.forEach((config) => {
    for (let i = 0; i < 3; i += 1) {
      const radius = Math.random() * 0.9 + 0.6;
      const height = radius * (0.7 + Math.random() * 0.4);
      const drift = createSnowMound(radius, height, 0xffffff);
      drift.position.set(
        config.position.x + (Math.random() - 0.5) * 5,
        0.02,
        config.position.z + (Math.random() - 0.5) * 5,
      );
      cabinPiles.add(drift);
    }
  });
  scene.add(cabinPiles);

  const cabinBounds = cabinConfigs.map((config) => calculateCabinBounds(config));

  for (let i = 0; i < 32; i += 1) {
    const angle = (Math.PI * 2 * i) / 32;
    const radius = 40 + Math.random() * 20;
    const position = new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
    if (isNearCabin(position, cabinBounds)) continue;
    const tree = createTree();
    tree.position.copy(position);
    scene.add(tree);
  }

  return { ground, cabins: cabinSurfaces };

  function computeFrontAnchor(config) {
    const facing = config.style.facing || 0;
    const frontDir = new THREE.Vector3(Math.sin(facing), 0, Math.cos(facing));
    const porchDepth = config.style.porch?.depth || config.style.porchDepth || 2.2;
    const offset = config.style.body.depth / 2 + porchDepth + 0.8;
    return new THREE.Vector3(config.position.x, 0.04, config.position.z).add(
      frontDir.multiplyScalar(offset),
    );
  }

  function createCurvedVillagePaths(anchors) {
    if (!anchors.length) return [];
    const pathSegments = [];
    const pathY = 0.035;

    // 1. Create the main, irregular path
    const mainPathPoints = [
      new THREE.Vector3(4, pathY, -45),
      new THREE.Vector3(-3, pathY, -20),
      new THREE.Vector3(2, pathY, 0),
      new THREE.Vector3(-4, pathY, 25),
      new THREE.Vector3(5, pathY, 45),
    ];
    const mainCurve = new THREE.CatmullRomCurve3(mainPathPoints);
    const mainPathMesh = createPathFromCurve(mainCurve, 4.5);
    scene.add(mainPathMesh);
    pathSegments.push({ start: mainPathPoints[0], end: mainPathPoints[mainPathPoints.length - 1], width: 4.5 });

    // 2. Create branching paths to each cabin
    anchors.forEach(({ front: cabinDoor }) => {
      // Find the closest point on the main path to branch from
      const closestPointOnMain = mainCurve.getPointAt(
        mainCurve.getUtoTmapping(
          mainCurve.getPoint(0.5), // start search from middle
          cabinDoor,
        ),
      );

      // Create a gentle curve for the branch
      const controlPoint = new THREE.Vector3().lerpVectors(cabinDoor, closestPointOnMain, 0.4);
      controlPoint.y = pathY;

      const branchCurve = new THREE.CatmullRomCurve3([
        closestPointOnMain,
        controlPoint,
        cabinDoor,
      ]);
      const pathMesh = createPathFromCurve(branchCurve, 2.2);
      scene.add(pathMesh);
      pathSegments.push({ start: closestPointOnMain.clone(), end: cabinDoor.clone(), width: 2.2 });
    });

    return pathSegments;
  }

  function createPathFromCurve(curve, width) {
    const tubeSegments = 120;
    const radiusSegments = 8;
    const geometry = new THREE.TubeGeometry(curve, tubeSegments, width / 2, radiusSegments, false);

    const stoneTexture = new THREE.CanvasTexture(generateStoneTexture());
    stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
    const pathLength = curve.getLength();
    stoneTexture.repeat.set(pathLength / 5, 1);

    const mesh = new THREE.Mesh(
      geometry,
      new THREE.MeshStandardMaterial({
        map: stoneTexture,
        color: 0xe0e0e0,
        roughness: 0.95,
        metalness: 0.05,
      }),
    );

    // Flatten the tube to make it a path
    const positions = mesh.geometry.attributes.position;
    for (let i = 0; i < positions.count; i++) {
      const y = positions.getY(i);
      positions.setY(i, y * 0.1); // Scale down the Y-axis
    }
    positions.needsUpdate = true;
    mesh.geometry.computeVertexNormals();

    mesh.castShadow = false;
    mesh.receiveShadow = true;
    return mesh;
  }

  function computePathBounds(segments) {
    const bounds = [];
    segments.forEach((segment) => {
      bounds.push({
        x1: Math.min(segment.start.x, segment.end.x) - segment.width,
        x2: Math.max(segment.start.x, segment.end.x) + segment.width,
        z1: Math.min(segment.start.z, segment.end.z) - segment.width,
        z2: Math.max(segment.start.z, segment.end.z) + segment.width,
      });
    });
    return bounds;
  }

  function isOnPath(position, pathBounds) {
    return pathBounds.some(
      (bound) =>
        position.x >= bound.x1 &&
        position.x <= bound.x2 &&
        position.z >= bound.z1 &&
        position.z <= bound.z2,
    );
  }

  function calculateCabinBounds(config) {
    const style = config.style;
    let halfWidth = style.body.width / 2;
    let halfDepth = style.body.depth / 2;

    if (style.upperBody) {
      halfWidth = Math.max(halfWidth, style.upperBody.width / 2);
      halfDepth = Math.max(halfDepth, style.upperBody.depth / 2);
    }

    if (style.modules) {
      style.modules.forEach((module) => {
        halfWidth = Math.max(
          halfWidth,
          Math.abs(module.offsetX || 0) + module.width / 2,
        );
        halfDepth = Math.max(
          halfDepth,
          Math.abs(module.offsetZ || 0) + module.depth / 2,
        );
      });
    }

    if (style.porch) {
      halfWidth = Math.max(
        halfWidth,
        (style.porch.widthFactor || 1) * style.body.width * 0.5 + 1.5,
      );
      halfDepth = Math.max(
        halfDepth,
        style.body.depth / 2 + (style.porch.depth || 2.5) + 2,
      );
    }

    const padding = 6;
    halfWidth += padding;
    halfDepth += padding;

    return {
      x: config.position.x,
      z: config.position.z,
      width: halfWidth * 2,
      depth: halfDepth * 2,
    };
  }

  function isNearCabin(position, bounds) {
    return bounds.some((cabin) => {
      return (
        Math.abs(position.x - cabin.x) < cabin.width / 2 &&
        Math.abs(position.z - cabin.z) < cabin.depth / 2
      );
    });
  }
}

function createCabin(config) {
  const { id, position, style } = config;
  const group = new THREE.Group();
  group.position.set(position.x, 0, position.z);
  group.rotation.y = style.facing || 0;
  const surfaces = [];

  const bodyVolume = createLogVolume(
    style.body.width,
    style.body.height,
    style.body.depth,
    style.body.color,
  );
  bodyVolume.group.position.y = style.body.height / 2;
  group.add(bodyVolume.group);
  surfaces.push(bodyVolume.surface);

  let roofBaseHeight = style.body.height;

  if (style.upperBody) {
    const upper = style.upperBody;
    const upperVolume = createLogVolume(
      upper.width,
      upper.height,
      upper.depth,
      upper.color || style.body.color,
    );
    upperVolume.group.position.y = style.body.height + upper.height / 2 + (upper.offsetY || 0);
    group.add(upperVolume.group);
    surfaces.push(upperVolume.surface);
    roofBaseHeight = upperVolume.group.position.y + upper.height / 2;
  }

  if (style.modules) {
    style.modules.forEach((module) => {
      const moduleVolume = createLogVolume(
        module.width,
        module.height,
        module.depth,
        module.color || style.body.color,
      );
      moduleVolume.group.position.set(
        module.offsetX || 0,
        (module.offsetY || 0) + module.height / 2,
        module.offsetZ || 0,
      );
      group.add(moduleVolume.group);
      surfaces.push(moduleVolume.surface);
    });
  }

  const roofMat = new THREE.MeshStandardMaterial({
    color: style.roof.color,
    roughness: 0.6,
    metalness: 0.05,
  });

  const halfDepth = style.body.depth / 2 + 0.2;
  const gableShape = new THREE.Shape();
  gableShape.moveTo(-halfDepth, 0);
  gableShape.lineTo(halfDepth, 0);
  gableShape.lineTo(0, style.roof.height);
  gableShape.closePath();

  const roofDepth = style.body.width + 0.2;
  const extrudeSettings = { depth: roofDepth, bevelEnabled: false };
  const gableGeometry = new THREE.ExtrudeGeometry(gableShape, extrudeSettings);
  gableGeometry.translate(0, roofBaseHeight, -roofDepth / 2);
  gableGeometry.rotateY(Math.PI / 2);

  const roof = new THREE.Mesh(gableGeometry, roofMat);
  roof.castShadow = true;
  roof.receiveShadow = true;
  group.add(roof);
  surfaces.push(roof);

  if (style.dormers) {
    style.dormers.forEach((dormer) => {
      const dormerGeo = new THREE.BoxGeometry(dormer.width, dormer.height, dormer.depth);
      const dormerMat = new THREE.MeshStandardMaterial({
        color: dormer.color || style.trimColor || 0xf5e4cf,
        roughness: 0.75,
      });
      const dormerMesh = new THREE.Mesh(dormerGeo, dormerMat);
      dormerMesh.position.set(
        dormer.offsetX || 0,
        roofBaseHeight + dormer.height / 2,
        dormer.offsetZ || 0,
      );
      dormerMesh.castShadow = true;
      dormerMesh.receiveShadow = true;
      group.add(dormerMesh);
      surfaces.push(dormerMesh);

      const dormerRoofShape = new THREE.Shape();
      const halfDormDepth = dormer.depth / 2 + 0.3;
      dormerRoofShape.moveTo(-halfDormDepth, 0);
      dormerRoofShape.lineTo(halfDormDepth, 0);
      dormerRoofShape.lineTo(0, dormer.height * 0.7);
      dormerRoofShape.closePath();
      const dormerRoof = new THREE.Mesh(
        new THREE.ExtrudeGeometry(dormerRoofShape, { depth: dormer.width, bevelEnabled: false }),
        new THREE.MeshStandardMaterial({
          color: dormer.roofColor || style.roof.color,
          roughness: 0.6,
          metalness: 0.05,
        }),
      );
      dormerRoof.position.set(dormerMesh.position.x, dormerMesh.position.y + dormer.height / 2, dormerMesh.position.z - dormer.width / 2);
      dormerRoof.rotation.y = Math.PI / 2;
      dormerRoof.castShadow = true;
      group.add(dormerRoof);
    });
  }


  if (style.chimney) {
    const chimney = new THREE.Mesh(
      new THREE.BoxGeometry(1.4, 3, 1.4),
      new THREE.MeshStandardMaterial({ color: 0x4b2a1a, roughness: 0.7 }),
    );
    chimney.position.set(style.body.width * 0.25, style.body.height + 2, -style.body.depth * 0.1);
    chimney.castShadow = true;
    group.add(chimney);
    surfaces.push(chimney);
  }

  const door = new THREE.Mesh(
    new THREE.BoxGeometry(1.8, 2.6, 0.25),
    new THREE.MeshStandardMaterial({
      color: style.doorColor || 0x4d2718,
      roughness: 0.8,
    }),
  );
  door.position.set(0, 1.3, style.body.depth / 2 + 0.12);
  group.add(door);

  const doorLight = new THREE.PointLight(style.trimColor || 0xfff4d4, 0.6, 10);
  doorLight.position.set(0, 3.8, style.body.depth / 2 + 0.5);
  group.add(doorLight);

  const windowMaterial = new THREE.MeshStandardMaterial({
    emissive: style.trimColor || 0xfff0c4,
    emissiveIntensity: 0.6,
    color: 0x111111,
  });
  const createWindow = (x, y, z) => {
    const win = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.4, 0.1), windowMaterial);
    win.position.set(x, y, z);
    group.add(win);
  };
  createWindow(-style.body.width * 0.35, style.body.height * 0.6, style.body.depth / 2 + 0.05);
  createWindow(style.body.width * 0.35, style.body.height * 0.6, style.body.depth / 2 + 0.05);

  if (style.shuttersColor) {
    const shutterMaterial = new THREE.MeshStandardMaterial({
      color: style.shuttersColor,
      roughness: 0.7,
    });
    const shutter = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.08), shutterMaterial);
    const shutterLeft = shutter.clone();
    shutterLeft.position.set(-style.body.width * 0.5 + 0.3, style.body.height * 0.6, style.body.depth / 2 + 0.06);
    group.add(shutterLeft);
    const shutterRight = shutter.clone();
    shutterRight.position.x = -shutterLeft.position.x;
    group.add(shutterRight);
  }

  if (style.wreathColor) {
    const wreath = new THREE.Mesh(
      new THREE.TorusGeometry(1.2, 0.2, 12, 24),
      new THREE.MeshStandardMaterial({
        color: style.wreathColor,
        emissive: style.wreathColor,
        emissiveIntensity: 0.3,
      }),
    );
    wreath.position.set(0, style.body.height * 0.85, style.body.depth / 2 + 0.2);
    group.add(wreath);
  }

  if (style.stringLightsColor) {
    const lights = new THREE.Group();
    const bulbMat = new THREE.MeshStandardMaterial({
      color: style.stringLightsColor,
      emissive: style.stringLightsColor,
      emissiveIntensity: 0.8,
    });
    const bulbCount = 10;
    for (let i = 0; i < bulbCount; i += 1) {
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 10, 10), bulbMat);
      const t = i / (bulbCount - 1);
      bulb.position.set(
        -style.body.width * 0.45 + t * style.body.width * 0.9,
        style.body.height + 0.5 + Math.sin(t * Math.PI) * 0.7,
        style.body.depth / 2 + 0.35,
      );
      lights.add(bulb);
    }
    group.add(lights);
  }

  if (style.porch) {
    const porchWidth = style.body.width * (style.porch.widthFactor || 0.9);
    const porchDepth = style.porch.depth || 2.6;
    const porch = new THREE.Mesh(
      new THREE.BoxGeometry(porchWidth, 0.35, porchDepth),
      new THREE.MeshStandardMaterial({ color: 0xfefefe, roughness: 0.95 }),
    );
    porch.position.set(0, 0.2, style.body.depth / 2 + porchDepth / 2);
    porch.receiveShadow = true;
    group.add(porch);
    surfaces.push(porch);

    const columnCount = Math.max(2, style.porch.columns || 2);
    const doorClear = 3;
    const postMaterial = new THREE.MeshStandardMaterial({
      color: style.trimColor || 0xffeed0,
      roughness: 0.7,
    });
    const postPositions = [];
    for (let i = 0; i < columnCount; i += 1) {
      const t = columnCount === 1 ? 0 : i / (columnCount - 1);
      const x = -porchWidth / 2 + t * porchWidth;
      if (Math.abs(x) < doorClear / 2) continue;
      postPositions.push(x);
    }
    if (postPositions.length === 0) {
      postPositions.push(-porchWidth / 2 + 0.35, porchWidth / 2 - 0.35);
    }
    postPositions.forEach((x) => {
      const post = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 2.8, 0.3),
        postMaterial,
      );
      post.position.set(x, 1.4, porch.position.z + porchDepth / 2 - 0.35);
      post.castShadow = true;
      group.add(post);
    });

    if (style.porch.rails) {
      const railColor = style.trimColor || 0xffeed0;
      const available = porchWidth - doorClear - 0.6;
      if (available > 0.5) {
        const railLength = available / 2;
        const railGeom = new THREE.BoxGeometry(railLength, 0.15, 0.15);
        const railMat = new THREE.MeshStandardMaterial({ color: railColor, roughness: 0.6 });
        const leftRail = new THREE.Mesh(railGeom, railMat);
        leftRail.position.set(
          -doorClear / 2 - railLength / 2,
          1.4,
          porch.position.z + porchDepth / 2 - 0.35,
        );
        group.add(leftRail);
        const rightRail = new THREE.Mesh(railGeom, railMat);
        rightRail.position.set(
          doorClear / 2 + railLength / 2,
          1.4,
          porch.position.z + porchDepth / 2 - 0.35,
        );
        group.add(rightRail);
      }
    }

    if (style.porch.steps) {
      const stepCount = 3;
      for (let i = 0; i < stepCount; i += 1) {
        const step = new THREE.Mesh(
          new THREE.BoxGeometry(porchWidth * 0.8, 0.25, 0.6),
          new THREE.MeshStandardMaterial({ color: 0xfdfdfd, roughness: 0.95 }),
        );
        step.position.set(
          0,
          0.12 + i * 0.25,
          porch.position.z - porchDepth / 2 + 0.4 + i * 0.5,
        );
        group.add(step);
      }
    }

    if (style.porch.wrap) {
      const wrapWidth = style.body.depth + porchDepth;
      const sidePorch = new THREE.Mesh(
        new THREE.BoxGeometry(wrapWidth, 0.3, 0.9),
        new THREE.MeshStandardMaterial({ color: 0xfefefe, roughness: 0.95 }),
      );
      sidePorch.position.set(-porchWidth / 2 + 0.45, 0.18, 0);
      group.add(sidePorch);
      surfaces.push(sidePorch);
    }
  }

  if (style.balcony) {
    const balconyWidth = style.balcony.width || style.body.width * 0.6;
    const balconyDepth = style.balcony.depth || 3;
    const balconyHeight = style.balcony.height || style.body.height * 0.75;
    const balcony = new THREE.Mesh(
      new THREE.BoxGeometry(balconyWidth, 0.3, balconyDepth),
      new THREE.MeshStandardMaterial({
        color: style.balcony.railColor || style.trimColor || 0xffeed0,
        roughness: 0.8,
      }),
    );
    const balconyZ = -style.body.depth / 2 - balconyDepth / 2;
    balcony.position.set(0, balconyHeight, balconyZ);
    group.add(balcony);
    surfaces.push(balcony);

    const railing = new THREE.Mesh(
      new THREE.BoxGeometry(balconyWidth, 0.15, 0.15),
      new THREE.MeshStandardMaterial({
        color: style.balcony.railColor || style.trimColor || 0xffeed0,
        roughness: 0.6,
      }),
    );
    railing.position.set(0, balconyHeight + 0.6, balconyZ + balconyDepth / 2 - 0.1);
    group.add(railing);
  }

  return { id, group, surfaces };
}

function createTree() {
  const group = new THREE.Group();
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.4, 2, 6),
    new THREE.MeshStandardMaterial({ color: 0x4d331f }),
  );
  trunk.position.y = 1;
  group.add(trunk);

  const levels = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < levels; i += 1) {
    const cone = new THREE.Mesh(
      new THREE.ConeGeometry(1.8 - i * 0.2, 2, 8),
      new THREE.MeshStandardMaterial({ color: 0x1c5b32, roughness: 0.9 }),
    );
    cone.position.y = 2 + i * 1.1;
    cone.castShadow = true;
    group.add(cone);

    const snowCap = new THREE.Mesh(
      new THREE.ConeGeometry(Math.max(0.4, 1.2 - i * 0.18), 0.3, 8),
      new THREE.MeshStandardMaterial({ color: 0xf4fbff, roughness: 0.4 }),
    );
    snowCap.position.y = cone.position.y + 0.8;
    group.add(snowCap);
  }
  return group;
}

function generateLogTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#c66726';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const logHeight = 32;
  for (let y = -logHeight; y < canvas.height + logHeight; y += logHeight) {
    const gradient = ctx.createLinearGradient(0, y, 0, y + logHeight);
    gradient.addColorStop(0, '#7a2f07');
    gradient.addColorStop(0.25, '#b35b1b');
    gradient.addColorStop(0.5, '#e38b3d');
    gradient.addColorStop(0.75, '#b35317');
    gradient.addColorStop(1, '#6a2704');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, y, canvas.width, logHeight);

    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0, y + logHeight - 3, canvas.width, 3);

    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(0, y + 4, canvas.width, 2);

    ctx.strokeStyle = 'rgba(96, 60, 30, 0.35)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.1, y + logHeight * 0.35);
    ctx.quadraticCurveTo(canvas.width * 0.4, y + logHeight * 0.15, canvas.width * 0.65, y + logHeight * 0.3);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.2, y + logHeight * 0.55);
    ctx.quadraticCurveTo(canvas.width * 0.45, y + logHeight * 0.35, canvas.width * 0.85, y + logHeight * 0.5);
    ctx.stroke();
  }

  return canvas;
}

function generateStoneTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#7e808a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 140; i += 1) {
    const cx = Math.random() * canvas.width;
    const cy = Math.random() * canvas.height;
    const radius = 25 + Math.random() * 35;
    const points = 6 + Math.floor(Math.random() * 5);
    ctx.beginPath();
    for (let p = 0; p < points; p += 1) {
      const angle = (Math.PI * 2 * p) / points;
      const offset = radius + Math.random() * 12;
      const x = cx + Math.cos(angle) * offset;
      const y = cy + Math.sin(angle) * offset;
      p === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.closePath();
    const gradient = ctx.createRadialGradient(cx, cy, radius * 0.2, cx, cy, radius);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
    gradient.addColorStop(0.6, 'rgba(170, 175, 186, 0.95)');
    gradient.addColorStop(1, 'rgba(70, 72, 80, 0.95)');
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.strokeStyle = 'rgba(40, 42, 48, 0.6)';
    ctx.lineWidth = 2.2;
    ctx.stroke();
  }

  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 80; i += 1) {
    ctx.beginPath();
    ctx.ellipse(
      Math.random() * canvas.width,
      Math.random() * canvas.height,
      10,
      4,
      Math.random() * Math.PI,
      0,
      Math.PI * 2,
    );
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  return canvas;
}

function createLogVolume(width, height, depth, color = 0x8a3b10) {
  const group = new THREE.Group();
  const logRadius = 0.45;
  const logDiameter = logRadius * 2;
  const rows = Math.ceil(height / logDiameter);
  const logMaterial = new THREE.MeshStandardMaterial({
    color,
    roughness: 0.78,
    metalness: 0.03,
  });

  const createHorizontalLayer = (length, axis) => {
    const geometry = new THREE.CylinderGeometry(logRadius, logRadius, length + 0.4, 18);
    for (let row = 0; row < rows; row += 1) {
      const y = -height / 2 + (row + 0.5) * logDiameter;
      const log = new THREE.Mesh(geometry, logMaterial);
      if (axis === 'z') {
        log.rotation.z = Math.PI / 2;
        log.position.set(0, y, -depth / 2 + logRadius);
        group.add(log);
        const backLog = log.clone();
        backLog.position.z = depth / 2 - logRadius;
        group.add(backLog);
      } else {
        log.rotation.x = Math.PI / 2;
        log.position.set(-width / 2 + logRadius, y, 0);
        group.add(log);
        const opp = log.clone();
        opp.position.x = width / 2 - logRadius;
        group.add(opp);
      }
    }
  };

  createHorizontalLayer(width, 'z');
  createHorizontalLayer(depth, 'x');

  const cornerMaterial = logMaterial;
  const cornerGeom = new THREE.CylinderGeometry(logRadius * 1.25, logRadius * 1.25, height + 0.5, 16);
  const cornerPositions = [
    [-width / 2 - logRadius * 0.2, 0, -depth / 2 - logRadius * 0.2],
    [width / 2 + logRadius * 0.2, 0, -depth / 2 - logRadius * 0.2],
    [-width / 2 - logRadius * 0.2, 0, depth / 2 + logRadius * 0.2],
    [width / 2 + logRadius * 0.2, 0, depth / 2 + logRadius * 0.2],
  ];
  cornerPositions.forEach(([x, y, z]) => {
    const cornerLog = new THREE.Mesh(cornerGeom, cornerMaterial);
    cornerLog.position.set(x, y, z);
    cornerLog.castShadow = true;
    cornerLog.receiveShadow = true;
    group.add(cornerLog);
  });

  const collider = new THREE.Mesh(
    new THREE.BoxGeometry(width, height, depth),
    new THREE.MeshBasicMaterial({ visible: false }),
  );
  group.add(collider);

  return { group, surface: collider };
}

function createSnowMound(radius, height, color = 0xffffff) {
  const steps = 18;
  const flatness = 0.6 + Math.random() * 0.4; // some heaps flatter
  const widthNoise = 0.8 + Math.random() * 0.4;
  const profile = [];
  for (let i = 0; i <= steps; i += 1) {
    const t = i / steps;
    const y = t * height;
    const falloff = Math.pow(1 - t * flatness, 1.4);
    const baseRadius = radius * widthNoise * (0.2 + 0.8 * falloff);
    const jitter = (Math.random() - 0.5) * radius * 0.1 * (1 - t);
    const tipFlatten = radius * (0.25 + Math.random() * 0.1) * Math.pow(t, 2);
    const r = Math.max(0.08, baseRadius + jitter - tipFlatten);
    profile.push(new THREE.Vector2(r, y));
  }
  const geometry = new THREE.LatheGeometry(profile, 18);
  const positions = geometry.attributes.position;
  for (let i = 0; i < positions.count; i += 1) {
    const y = positions.getY(i);
    const normalized = height > 0 ? y / height : 0;
    const lateralNoise = (Math.random() - 0.5) * radius * 0.06 * (1 - normalized);
    positions.setX(i, positions.getX(i) + lateralNoise);
    positions.setZ(i, positions.getZ(i) + lateralNoise * 0.7);
  }
  positions.needsUpdate = true;
  geometry.computeVertexNormals();

  const material = new THREE.MeshBasicMaterial({ color });
  const mound = new THREE.Mesh(geometry, material);
  mound.castShadow = false;
  mound.receiveShadow = true;
  return mound;
}

function createSnowSystem(count) {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const speeds = new Float32Array(count);

  for (let i = 0; i < count; i += 1) {
    positions[i * 3] = (Math.random() - 0.5) * 120;
    positions[i * 3 + 1] = Math.random() * 40 + 5;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 120;
    speeds[i] = Math.random() * 0.3 + 0.1;
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));

  const material = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.15,
    transparent: true,
    opacity: 0.8,
  });

  const points = new THREE.Points(geometry, material);

  return { points, positions, speeds };
}

function createAvatar(appearance = {}) {
  const config = normalizeAvatarAppearance(appearance);
  const group = new THREE.Group();
  const dynamicMaterials = [];

  function registerMaterial(material, key, { emissive } = {}) {
    dynamicMaterials.push({ material, key, emissive: Boolean(emissive) });
    return material;
  }

  function applyColors(colors) {
    if (!colors) return;
    dynamicMaterials.forEach(({ material, key, emissive }) => {
      const color = colors[key];
      if (!color) return;
      material.color.set(color);
      if (emissive && material.emissive) {
        material.emissive.set(color);
      }
    });
  }

  const bodyMat = registerMaterial(
    new THREE.MeshStandardMaterial({ color: config.colors.outfit, roughness: 0.45, metalness: 0.05 }),
    'outfit',
  );
  const accentMat = registerMaterial(
    new THREE.MeshStandardMaterial({
      color: config.colors.accent,
      emissive: config.colors.accent,
      emissiveIntensity: 0.35,
      roughness: 0.25,
      metalness: 0.1,
    }),
    'accent',
    { emissive: true },
  );

  const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1.6, 6, 12), bodyMat);
  body.castShadow = true;
  body.position.y = 1.5;
  group.add(body);

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.5, 24, 16),
    new THREE.MeshStandardMaterial({ color: 0xfff3eb }),
  );
  head.position.y = 2.6;
  head.castShadow = true;
  group.add(head);

  const scarf = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.15, 8, 18), accentMat);
  scarf.rotation.x = Math.PI / 2;
  scarf.position.y = 2.2;
  group.add(scarf);

  const outfitGroup = new THREE.Group();
  group.add(outfitGroup);

  const outfitVariants = {
    parka: (() => {
      const hood = new THREE.Mesh(
        new THREE.SphereGeometry(0.95, 24, 18, 0, Math.PI * 2, 0, Math.PI / 1.5),
        registerMaterial(
          new THREE.MeshStandardMaterial({
            color: config.colors.accent,
            roughness: 0.25,
            metalness: 0.05,
            emissive: config.colors.accent,
            emissiveIntensity: 0.2,
          }),
          'accent',
          { emissive: true },
        ),
      );
      hood.position.y = 2.35;
      hood.scale.set(1, 0.8, 1);
      return hood;
    })(),
    cape: (() => {
      const cape = new THREE.Mesh(
        new THREE.PlaneGeometry(3, 3.2, 1, 1),
        registerMaterial(
          new THREE.MeshStandardMaterial({
            color: config.colors.outfit,
            roughness: 0.5,
            transparent: true,
            opacity: 0.82,
            side: THREE.DoubleSide,
          }),
          'outfit',
        ),
      );
      cape.position.set(0, 1.8, 1);
      cape.rotation.x = Math.PI / 8;
      cape.rotation.z = Math.PI / 36;
      return cape;
    })(),
    sweater: (() => {
      const sweaterGroup = new THREE.Group();
      const torso = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 1.2, 0.8),
        registerMaterial(
          new THREE.MeshStandardMaterial({ color: config.colors.outfit, roughness: 0.85 }),
          'outfit',
        ),
      );
      torso.position.y = 1.7;
      sweaterGroup.add(torso);

      const cuffs = new THREE.Mesh(
        new THREE.TorusGeometry(0.75, 0.12, 10, 24),
        registerMaterial(
          new THREE.MeshStandardMaterial({
            color: config.colors.accent,
            roughness: 0.4,
            emissive: config.colors.accent,
            emissiveIntensity: 0.2,
          }),
          'accent',
          { emissive: true },
        ),
      );
      cuffs.position.y = 1.1;
      cuffs.rotation.x = Math.PI / 2;
      sweaterGroup.add(cuffs);
      return sweaterGroup;
    })(),
  };

  Object.values(outfitVariants).forEach((variant) => {
    variant.visible = false;
    outfitGroup.add(variant);
  });

  const hairGroup = new THREE.Group();
  group.add(hairGroup);

  const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x2f1b13, roughness: 0.7 });
  const hairVariants = {
    'soft-wave': (() => {
      const waves = new THREE.Mesh(new THREE.TorusGeometry(0.75, 0.18, 12, 24), hairMaterial.clone());
      waves.rotation.x = Math.PI / 2;
      waves.position.y = 2.4;
      return waves;
    })(),
    'braided-crown': (() => {
      const braid = new THREE.Group();
      for (let i = 0; i < 6; i += 1) {
        const bead = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), hairMaterial.clone());
        const angle = (Math.PI * 2 * i) / 6;
        bead.position.set(Math.cos(angle) * 0.65, 2.35, Math.sin(angle) * 0.65);
        braid.add(bead);
      }
      return braid;
    })(),
    'pom-hat': (() => {
      const groupHat = new THREE.Group();
      const hatBody = new THREE.Mesh(
        new THREE.CylinderGeometry(0.7, 0.8, 0.7, 16),
        registerMaterial(
          new THREE.MeshStandardMaterial({ color: config.colors.outfit, roughness: 0.35 }),
          'outfit',
        ),
      );
      hatBody.position.y = 2.8;
      groupHat.add(hatBody);

      const pom = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 12, 12),
        registerMaterial(
          new THREE.MeshStandardMaterial({
            color: config.colors.accent,
            emissive: config.colors.accent,
            emissiveIntensity: 0.25,
          }),
          'accent',
          { emissive: true },
        ),
      );
      pom.position.y = 3.3;
      groupHat.add(pom);
      return groupHat;
    })(),
  };

  Object.values(hairVariants).forEach((variant) => {
    variant.visible = false;
    hairGroup.add(variant);
  });

  const appearanceState = {
    colors: { ...config.colors },
    outfit: config.outfit,
    hair: config.hair,
  };

  function setOutfit(name) {
    appearanceState.outfit = outfitVariants[name] ? name : 'parka';
    Object.entries(outfitVariants).forEach(([key, variant]) => {
      variant.visible = key === appearanceState.outfit;
    });
  }

  function setHair(name) {
    appearanceState.hair = hairVariants[name] ? name : 'soft-wave';
    Object.entries(hairVariants).forEach(([key, variant]) => {
      variant.visible = key === appearanceState.hair;
    });
  }

  function setColors(colors) {
    appearanceState.colors = { ...appearanceState.colors, ...colors };
    applyColors(appearanceState.colors);
  }

  setOutfit(appearanceState.outfit);
  setHair(appearanceState.hair);
  applyColors(appearanceState.colors);

  return {
    group,
    materials: { body: bodyMat, accent: accentMat },
    setColors,
    setOutfit,
    setHair,
    setAppearance: (next) => {
      if (!next) return;
      if (next.colors) setColors(next.colors);
      if (next.outfit) setOutfit(next.outfit);
      if (next.hair) setHair(next.hair);
    },
  };
}

function setupUI() {
  joinInput.addEventListener('input', () => {
    joinInput.value = joinInput.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
  });

  startButton.addEventListener('click', () => {
    network.ensureConnection();
    network.send('create_session', {
      displayName: randomSnowyName(),
      avatar: {
        colors: localState.avatarColors,
        outfit: localState.outfit,
        hair: localState.hair,
      },
    });
  });

  joinButton.addEventListener('click', () => {
    const code = joinInput.value.trim().toUpperCase();
    if (code.length < 6) {
      showToast('Enter a 6-character invite code.');
      return;
    }
    network.ensureConnection();
    network.send('join_session', {
      code,
      displayName: randomSnowyName(),
      avatar: {
        colors: localState.avatarColors,
        outfit: localState.outfit,
        hair: localState.hair,
      },
    });
  });

  outfitColorInput.addEventListener('input', (event) => {
    localState.avatarColors.outfit = event.target.value;
    localPlayer.setColors({ outfit: event.target.value });
    sendAvatarUpdate();
  });

  accentColorInput.addEventListener('input', (event) => {
    localState.avatarColors.accent = event.target.value;
    localPlayer.setColors({ accent: event.target.value });
    sendAvatarUpdate();
  });

  outfitSelect.addEventListener('change', (event) => {
    localState.outfit = event.target.value;
    localPlayer.setOutfit(event.target.value);
    sendAvatarUpdate();
  });

  hairSelect.addEventListener('change', (event) => {
    localState.hair = event.target.value;
    localPlayer.setHair(event.target.value);
    sendAvatarUpdate();
  });

  decorColorInput.addEventListener('input', (event) => {
    localState.decorColor = event.target.value;
  });

  decorSelect.addEventListener('change', (event) => {
    localState.decorType = event.target.value;
  });

  snowToggle.addEventListener('click', () => {
    localState.snowMultiplier = localState.snowMultiplier === 1 ? 1.8 : 1;
    showToast(localState.snowMultiplier > 1 ? 'Snowfall intensified ❄️' : 'Snowfall relaxed ☁️');
  });

  photoModeBtn.addEventListener('click', () => {
    document.body.classList.toggle('photo-mode');
    const label = document.body.classList.contains('photo-mode') ? 'Exit Photo Mode' : 'Photo Mode';
    photoModeBtn.textContent = label;
  });
}

function setupInput() {
  window.addEventListener('keydown', (event) => {
    if (event.repeat) return;
    switch (event.key.toLowerCase()) {
      case 'w':
      case 'arrowup':
        inputState.forward = true;
        break;
      case 's':
      case 'arrowdown':
        inputState.backward = true;
        break;
      case 'a':
      case 'arrowleft':
        inputState.left = true;
        break;
      case 'd':
      case 'arrowright':
        inputState.right = true;
        break;
      case 'p':
        photoModeBtn.click();
        break;
      default:
        break;
    }
  });

  window.addEventListener('keyup', (event) => {
    switch (event.key.toLowerCase()) {
      case 'w':
      case 'arrowup':
        inputState.forward = false;
        break;
      case 's':
      case 'arrowdown':
        inputState.backward = false;
        break;
      case 'a':
      case 'arrowleft':
        inputState.left = false;
        break;
      case 'd':
      case 'arrowright':
        inputState.right = false;
        break;
      default:
        break;
    }
  });

  renderer.domElement.addEventListener('pointerdown', (event) => {
    dragState.active = true;
    dragState.moved = false;
    dragState.pointerId = event.pointerId;
    dragState.lastX = event.clientX;
    dragState.lastY = event.clientY;
    renderer.domElement.setPointerCapture(event.pointerId);
  });

  renderer.domElement.addEventListener('pointermove', (event) => {
    if (!dragState.active || event.pointerId !== dragState.pointerId) return;
    const deltaX = event.clientX - dragState.lastX;
    const deltaY = event.clientY - dragState.lastY;
    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
      dragState.moved = true;
    }
    cameraOrbit.yaw -= deltaX * 0.0045;
    cameraOrbit.pitch = THREE.MathUtils.clamp(cameraOrbit.pitch + deltaY * 0.0045, 0.1, 1.3);
    dragState.lastX = event.clientX;
    dragState.lastY = event.clientY;
  });

  renderer.domElement.addEventListener('pointerup', (event) => {
    if (event.pointerId !== dragState.pointerId) return;
    renderer.domElement.releasePointerCapture(event.pointerId);
    dragState.active = false;
    const pointerYawOffset = (0.5 - pointerState.x) * 1.6;
    const pointerPitchOffset = (pointerState.y - 0.5) * 0.7;
    cameraBase.yaw = cameraOrbit.yaw - pointerYawOffset;
    cameraBase.pitch = THREE.MathUtils.clamp(
      cameraOrbit.pitch - pointerPitchOffset,
      0.15,
      1.1,
    );
    if (!dragState.moved) {
      attemptDecorationPlacement(event);
    } else {
      autoFollowPaused = true;
      if (autoResumeTimeout) {
        clearTimeout(autoResumeTimeout);
      }
      autoResumeTimeout = setTimeout(() => {
        autoFollowPaused = false;
      }, AUTO_RESUME_DELAY_MS);
    }
    dragState.moved = false;
  });

  renderer.domElement.addEventListener('pointerleave', () => {
    dragState.active = false;
  });

  renderer.domElement.addEventListener(
    'wheel',
    (event) => {
      event.preventDefault();
      cameraOrbit.distance = THREE.MathUtils.clamp(
        cameraOrbit.distance + event.deltaY * 0.01,
        6,
        26,
      );
    },
    { passive: false },
  );

  window.addEventListener('resize', onResize);
  window.addEventListener('pointermove', handlePointerMove);
  window.addEventListener('touchmove', handleTouchMove, { passive: false });
}

function onResize() {
  const { innerWidth, innerHeight } = window;
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
}

function handlePointerMove(event) {
  pointerState.x = event.clientX / window.innerWidth;
  pointerState.y = event.clientY / window.innerHeight;
}

function handleTouchMove(event) {
  if (dragState.active || event.touches.length !== 1) return;
  const touch = event.touches[0];
  pointerState.x = touch.clientX / window.innerWidth;
  pointerState.y = touch.clientY / window.innerHeight;
}

function randomSnowyName() {
  const prefixes = ['Frosty', 'Twinkle', 'Cozy', 'Aurora', 'Starry', 'Maple', 'Pine', 'Velvet'];
  const suffixes = ['Heart', 'Haven', 'Glow', 'Wish', 'Spark', 'Cocoa', 'Holly', 'Wreath'];
  return `${prefixes[Math.floor(Math.random() * prefixes.length)]}${
    suffixes[Math.floor(Math.random() * suffixes.length)]
  }`;
}

function handleSessionJoined(data) {
  localState.playerId = data.playerId;
  localState.sessionCode = data.code;
  sessionPanel.classList.add('hidden');
  hudPanel.classList.remove('hidden');
  sessionCodeLabel.textContent = data.code;
  showToast('Connected! Invite your partner with the code above.');
  hydrateWorld(data.state);
  sendAvatarUpdate();
}

function hydrateWorld(state) {
  if (!state) return;
  const seenPlayers = new Set();
  state.players.forEach((player) => {
    seenPlayers.add(player.id);
    if (player.id === localState.playerId) {
      return;
    }
    const existing = remotePlayers.get(player.id);
    const normalized = normalizeAvatarAppearance(player.avatar);
    if (!existing) {
      const avatar = createAvatar(normalized);
      avatar.group.position.set(
        player.transform?.position?.x || 0,
        player.transform?.position?.y || 1,
        player.transform?.position?.z || 0,
      );
      scene.add(avatar.group);
      remotePlayers.set(player.id, { ...avatar, targetTransform: player.transform });
    } else {
      updateTransform(existing.group, player.transform);
      existing.setAppearance(normalized);
    }
  });

  remotePlayers.forEach((avatar, id) => {
    if (!seenPlayers.has(id)) {
      scene.remove(avatar.group);
      remotePlayers.delete(id);
    }
  });

  state.decorations?.forEach((decor) => upsertDecoration(decor));
  decorationMeshes.forEach((mesh, id) => {
    if (!state.decorations.find((d) => d.id === id)) {
      scene.remove(mesh);
      decorationMeshes.delete(id);
    }
  });
}

function updateTransform(group, transform) {
  if (!transform) return;
  group.position.set(transform.position.x, transform.position.y, transform.position.z);
  group.rotation.y = transform.rotation.y || 0;
}

function attemptDecorationPlacement(event) {
  if (!localState.sessionCode) return;
  pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(placementSurfaces, true);
  if (!intersects.length) return;
  const hit = intersects[0];
  placeDecoration(hit.point, hit.face?.normal || new THREE.Vector3(0, 1, 0));
}

function placeDecoration(point, normal) {
  const decoration = {
    typeId: localState.decorType,
    color: localState.decorColor,
    glow: 0.6,
    transform: {
      position: { x: point.x, y: point.y, z: point.z },
      rotation: { x: 0, y: Math.atan2(normal.x, normal.z) || 0, z: 0 },
      scale: 1,
    },
  };

  network.send('place_decoration', decoration);
  showToast(`Placed ${localState.decorType.replace('_', ' ')} ✨`);
}

function upsertDecoration(data) {
  let mesh = decorationMeshes.get(data.id);
  if (!mesh) {
    mesh = createDecorationMesh(data);
    decorationMeshes.set(data.id, mesh);
    scene.add(mesh);
  }
  mesh.position.set(data.transform.position.x, data.transform.position.y, data.transform.position.z);
  mesh.rotation.y = data.transform.rotation.y || 0;
}

function createDecorationMesh(data) {
  let mesh;
  const color = new THREE.Color(data.color || '#fff8e7');
  switch (data.type) {
    case 'wreath':
      mesh = new THREE.Mesh(
        new THREE.TorusGeometry(1.1, 0.2, 16, 32),
        new THREE.MeshStandardMaterial({ color }),
      );
      mesh.position.y += 2;
      break;
    case 'snowglobe':
      mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.8, 20, 16),
        new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          metalness: 0,
          roughness: 0,
          transmission: 0.6,
          thickness: 0.6,
        }),
      );
      break;
    case 'lantern':
      mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12),
        new THREE.MeshStandardMaterial({ color }),
      );
      mesh.add(new THREE.PointLight(color.getHex(), 0.8, 8));
      break;
    case 'string_lights':
    default: {
      const group = new THREE.Group();
      const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6 });
      for (let i = 0; i < 6; i += 1) {
        const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), material);
        bulb.position.set(-1.5 + i * 0.6, 2.2 + Math.sin(i) * 0.2, 0);
        group.add(bulb);
      }
      mesh = group;
      break;
    }
  }
  return mesh;
}

function sendAvatarUpdate() {
  if (!localState.sessionCode || !network.socket) return;
  const transform = {
    position: {
      x: localPlayer.group.position.x,
      y: localPlayer.group.position.y,
      z: localPlayer.group.position.z,
    },
    rotation: { x: 0, y: localPlayer.group.rotation.y, z: 0 },
  };
  network.send('update_avatar', {
    transform,
    avatar: { colors: localState.avatarColors, outfit: localState.outfit, hair: localState.hair },
  });
}

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  updatePlayer(delta);
  updateSnow(delta);
  renderer.render(scene, camera);
}

function updatePlayer(delta) {
  if (!dragState.active && !autoFollowPaused) {
    const yawEdgeDirection =
      pointerState.x < EDGE_THRESHOLD ? 1 : pointerState.x > 1 - EDGE_THRESHOLD ? -1 : 0;
    const pitchEdgeDirection =
      pointerState.y < EDGE_THRESHOLD ? -1 : pointerState.y > 1 - EDGE_THRESHOLD ? 1 : 0;
    if (yawEdgeDirection !== 0) {
      cameraBase.yaw += yawEdgeDirection * EDGE_PAN_SPEED * delta;
    }
    if (pitchEdgeDirection !== 0) {
      cameraBase.pitch = THREE.MathUtils.clamp(
        cameraBase.pitch + pitchEdgeDirection * EDGE_TILT_SPEED * delta,
        0.15,
        1.1,
      );
    }
    const pointerYawOffset = (0.5 - pointerState.x) * 1.6;
    const pointerPitchOffset = (pointerState.y - 0.5) * 0.7;
    const yawTarget = cameraBase.yaw + pointerYawOffset;
    const pitchTarget = THREE.MathUtils.clamp(
      cameraBase.pitch + pointerPitchOffset,
      0.15,
      1.1,
    );
    cameraOrbit.yaw = THREE.MathUtils.lerp(cameraOrbit.yaw, yawTarget, 0.08);
    cameraOrbit.pitch = THREE.MathUtils.lerp(cameraOrbit.pitch, pitchTarget, 0.08);
  }

  const forwardInput = (inputState.forward ? 1 : 0) - (inputState.backward ? 1 : 0);
  const strafeInput = (inputState.right ? 1 : 0) - (inputState.left ? 1 : 0);
  const forwardDir = new THREE.Vector3(
    -Math.sin(cameraOrbit.yaw),
    0,
    -Math.cos(cameraOrbit.yaw),
  ).normalize();
  const rightDir = new THREE.Vector3().crossVectors(forwardDir, new THREE.Vector3(0, 1, 0)).normalize();

  const moveVector = new THREE.Vector3();
  if (forwardInput !== 0) moveVector.add(forwardDir.clone().multiplyScalar(forwardInput));
  if (strafeInput !== 0) moveVector.add(rightDir.clone().multiplyScalar(strafeInput));

  if (moveVector.lengthSq() > 0) {
    const facing = moveVector.clone().normalize();
    localPlayer.group.position.add(facing.multiplyScalar(delta * 6));
    const angle = Math.atan2(moveVector.x, moveVector.z);
    localPlayer.group.rotation.y = angle;
    sendAvatarUpdate();
  }

  cameraTarget.lerp(localPlayer.group.position, 0.08);
  const offset = new THREE.Vector3(
    Math.sin(cameraOrbit.yaw) * Math.cos(cameraOrbit.pitch),
    Math.sin(cameraOrbit.pitch),
    Math.cos(cameraOrbit.yaw) * Math.cos(cameraOrbit.pitch),
  ).multiplyScalar(cameraOrbit.distance);

  const desiredPosition = localPlayer.group.position.clone().add(offset);
  camera.position.lerp(desiredPosition, 0.08);
  camera.lookAt(cameraTarget);
}

function updateSnow(delta) {
  const { points } = snowSystem;
  const positions = points.geometry.attributes.position;
  for (let i = 0; i < positions.count; i += 1) {
    let y = positions.getY(i);
    y -= snowSystem.speeds[i] * delta * 25 * localState.snowMultiplier;
    if (y < 0) {
      y = Math.random() * 40 + 10;
    }
    positions.setY(i, y);
  }
  positions.needsUpdate = true;
}

function showToast(message) {
  toastEl.textContent = message;
  toastEl.classList.add('visible');
  clearTimeout(showToast.timeout);
  showToast.timeout = setTimeout(() => toastEl.classList.remove('visible'), 2400);
}
